\subsection{Inital Assumptions}
In the beginning when starting to think about \cc within Kuadrant, assumptions were made about what the data would show.
Understanding these assumptions can give an insight into how the outcome from this research was made.

\subsubsection{Applications V's Operators}
The applications are Authorino and Limitador.
The operators are all the other operators and controllers, not just the operators related to the applications.
The assumption is the applications will have a much higher \cc score but have less high-ranked scores.
The reconcile loops can have very high \cc scores.

\subsubsection{Language Difference}
The three main languages that triggered this assumption cannot be more different in how they are written.
These languages are Golang, Rust and Python.

Golang is the primary language in all the operators and controllers.
As Golang treats errors as values, the code bases are littered with `if err != nil` and this adds choices to every function that will affect cyclomatic complexity score.
This feature means developers are forced to deal with the errors, but any argument that the \cc score is too high in functions needs to take into account errors as values will inflate the \cc score.

Rust on the other hand is different.
Its compiler does a lot of error checking that Golang just does not.
This comes from features like the Borrow Checker, itâ€™s much harder to get nil pointers, so it should be safe to have a code base with no nil pointer checks.
This language safety should lower the \cc score for its functions.
However, the mental loops a developer needs to jump through in Rust will be higher because of features like the Borrow Checker.

Python being used in the test suite repo and not compiled to a single binary.
Also does not have strict types and does not have errors as values like Golang.
It also did not have a `switch` like statement until a few years ago.
It is the language I expect to have the lowest-ranking scores of the three different languages.

