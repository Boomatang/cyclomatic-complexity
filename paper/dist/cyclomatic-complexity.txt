1

Introduction

This paper looks into the cyclomatic complexity in the Kuadrant project. Cyclomatic complexity
is a metric design to indicate complexity of an application. In the Kuadrant project there are
multiple applications and combining these metrics give some interesting insights.

1.1

Kuadrant Project

The Kuadrant Project is a collection of applications that provides gateway policies for kubernetes
and cross multi cluster.

2

Understanding Cyclomatic Complexity

Cyclomatic complexity is a measurement created from the control flow of an application. It uses
the number of edges and nodes in the control flow graph along with the number of connected
components. The common formula is M = E - N + 2P, where
• E = the number of edges of the graph.
• N = the number of nodes of the graph.
• P = the number of connected components.
There are other formulas depending on if the graph is a strongly connected graph but for this
scenario those do not matter.
The simplest understanding of how to calculate this metric is every time the function makes a
choice the one gets added to complexity and a function has a base level complexity of one. Below
are two example functions that produce the same output and both a cyclomatic complexity of two.
But the structure of each function is different.

The above examples show that readability may have no effect on the cyclomatic complexity
and by that point the style of a language or a team of programmers should not affect the overall
metric. What will affect the metric is how the tooling authors interpret the language control flow
features. For example a switch statement with cases that fall through to the next case can be
counted as one or the total number cases that are passed through.
As the Kuadrant project uses multiple languages we can only use the metric from a high level,
trending viewpoint.

2.1

Classifying Cyclomatic Complexity

The metric itself is a number but as a single number the metric is hard to reason about, so it is
bucketed into categories. While researching this work I came across a number of different bucketing
systems. I will use the bucket classification found on radon.readthedocs.io, it gives a good range
at both ends of the spectrum.
1

3

CC Score

Rank

Risk

1-5

A

Low - simple block

6 - 10

B

Low - well structured and stable block

11 - 20

C

Moderate - slightly complex block

21 - 30

D

More than moderate - more complex block

31 - 40

E

High - complex block, alarming

40+

F

Very high - error-prone, unstable block

testing

How cyclomatic complexity can be used in the context of testing.

4

Case Study: Cyclomatic Complexity in Kuadrant

4.1

Data collection and analysis

As the Kuadrant project is an open source project the analysis was only done on the public repos.
Any publicly archived repo was excluded along with any repo forked by the Kuadrant organisation.
To analysis the repo the following tools were used:
• gocyclo
• rust-code-analysis-cli
• RuboCop
These three tools covered five of the languages found in the project.
• Go
• Rust
• Python
• JavaScript
• Ruby
In total, 34 languages were detected in the project repos. The full list can be found in the
Languages section of the Reference. To collect the different languages scc was used. This tool will
also give a breakdown of the lines of code in a project. Which was helpful to graph how much of
the projects were being analysed by the different cyclomatic complexity tools.
Some projects had third party vendor code saved within. This vendor code was primarily
present in the early days of the projects. These third party blocks have been excluded from the
analysis. Their results skewed graphs with high peaks that did not add any value to the overall
outcome.
To select the points in time which each repo was scanned and analyse the merge commits were
used. In the case of the kuadrant-operator repo directly, the method of merging PRs changed
2

late 2022 and stopped adding the merge message to the git log. In this case every commit after
the latest merge was scanned and analysed. This process of checking the commits after the latest
merge commit was applied to every repo that was scanned.
All this data is collected with a notebook to allow for reproducible collection. The results
are normalised and stored in a Json file. The results need to be normalised as the cyclomatic
complexity tools all have different outputs. The collection process is currently not additive and
requires collection of data from the being of repos every time.
A second notebook provides the classification and visualisations of the collected data. This
only requires the Json file.

4.2

Inital Assumptions

In the beginning when starting to think about cyclomatic complexity within Kuadrant, assumptions
were made about what the data would show. Understanding these assumptions can give an insight
into how the outcomes from this research was made.
4.2.1

Applications V’s Operators

The applications are Authorino and Limitador. The operators are all the other operators and
controllers, not just the operators related to the applications. The assumption is the applications
will have a much higher CC score but have less higher ranked scores. The reconcile loops can have
very high CC scores.
4.2.2

Language Difference

The three main languages that triggered this assumption can not be more different in how they
are written. These languages are Golang, Rust and Python.
Golang of course being the primary language in all the operators and controllers. As Golang
treats errors as values, the code bases are littered with ‘if err != nil‘ and this adds choices to every
function which will affect cyclomatic complexity score. This feature means developers are forced
to deal with the errors but any argument that the CC score is too high in functions needs to take
into account errors as values will inflate the CC score.
Rust on the other hand is different. Its compiler does a lot of error checking that Golang just
does not. This comes from features like the Borrow Checker, it’s much harder to get nil pointers
so it is safe to have a code base with no nil pointer checks. This language safety should lower the
CC score for its functions. However, the mental loops a developer needs to jump through in Rust
will be higher because of features like the Borrow Checker.
Python being used in the test suite repo and not compiled to a single binary. Also does not
have strict types and does not have errors as values like Golang. It also did not have a ‘switch‘
like statement until a few years ago. It is the language I expect to have the lowest ranking scores
of the three different languages.

3

4.3

Lines of Code within Kuadrant and the analysis

An overall size of the Kuadrant project is required to know how much effect the cyclomatic complexity has over the project. The first chat is interesting as it shows the LoC for every repo. his
is interesting to see how and where the Kuadrant project grows over time. Now to see the amount
of the project code base that was scanned by the cyclomatic complexity tools.
As seen there is a very small amount of the LoC covered by the scan tools. A lot of the projects
are for working on kubernetes which relies heavily on YAML which we generate. This could be a
good explanation for the differences. The one thing to note on the scannable code is the rate of
change over time, while always increasing there are no steep increases.

4.4

Reference

4.4.1

Datafile

4.4.2

Projects

4.4.3

Project

First Merge

limitador

2020-05-20

authorino

2020-11-04

limitador-operator

2029-12-15

kuadrant-operator

2021-03-01

infinispan-rs

2021-04-20

kuadrantctl

2021-06-21

authorino-operator

2021-11-17

authorino-examples

2021-11-23

wasm-shim

2021-11-25

testsuite

2022-07-04

kuadrant.github.io

2022-08-08

multicluster-gateway-controller

2022-12-16

kuadra

2023-06-13

gateway-api-machinery

2023-06-20

docs.kuadrant.io

2023-07-05

.github

2023-07-26

gateway-api-state-merics

2023-08-24

governance

2024-01-18

Languages

• CSS
• CloudFormation
(YAML)
• Docker ignore

• Dockerfile

• Gemfile
• Go

• Extensible

Stylesheet

Language

Transforma-

• Go (gen)
• HTML

tions
4

• Handlebars

• Python

• JSON

• Rakefile

• JavaScript

• Ruby

• License

• Ruby (gen)

• Makefile

• Ruby HTML

• Markdown

• Rust

• Plain Text

• SQL

• Plain Text (min)

• SVG (min)

• Protocol Buffers

• Sass

• Shell
• Smarty Template
• TOML
• XML
• YAML
• YAML (min)
• gitignore

5

